<!doctype html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8" lang="en"><![endif]-->
<!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9" lang="en"><![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"><!--<![endif]-->
<head>
<meta charset="utf-8">
<title>Понимание методов Enumerable методом реализации их на Ruby &#8211; Diary of madman</title>
<meta name="description" content="Разбираемся что к чему">
<meta name="theme-color" content="#00d900">
<meta name="keywords" content="Ruby, Enumerable, Tutorial">


<!-- Twitter Cards -->
<meta name="twitter:title" content="Понимание методов Enumerable методом реализации их на Ruby">
<meta name="twitter:description" content="Разбираемся что к чему">
<meta name="twitter:site" content="@tonymadbrain">
<meta name="twitter:creator" content="@tonymadbrain">

<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://doam.ru/images/default-thumb.png">

<!-- Open Graph -->
<meta property="og:locale" content="en_US">
<meta property="og:type" content="article">
<meta property="og:title" content="Понимание методов Enumerable методом реализации их на Ruby">
<meta property="og:description" content="Разбираемся что к чему">
<meta property="og:url" content="http://doam.ru/understanding_enumerable_methods_by_re-implementing_them_in_ruby/">
<meta property="og:site_name" content="Diary of madman">





<link rel="canonical" href="http://doam.ru/understanding_enumerable_methods_by_re-implementing_them_in_ruby/">
<link href="http://doam.ru/feed.xml" type="application/atom+xml" rel="alternate" title="Diary of madman Feed">

<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- For all browsers -->
<link rel="stylesheet" href="http://doam.ru/assets/css/main.css">

<style type="text/css">
  @media screen and (min-width: 300px) {.footer_img {height: 50px;}}
  @media screen and (min-width: 600px) {.footer_img {height: 90px;}}
  @media screen and (min-width: 900px) {.footer_img {height: 90px;}}
</style>

<meta http-equiv="cleartype" content="on">

<!-- HTML5 Shiv and Media Query Support -->
<!--[if lt IE 9]>
	<script src="http://doam.ru/assets/js/vendor/html5shiv.min.js"></script>
	<script src="http://doam.ru/assets/js/vendor/respond.min.js"></script>
<![endif]-->

<!-- Modernizr -->
<script src="http://doam.ru/assets/js/vendor/modernizr-2.7.1.custom.min.js"></script>

<link href='//fonts.googleapis.com/css?family=PT+Sans+Narrow:400,700%7CPT+Serif:400,700,400italic' rel='stylesheet' type='text/css'>

<!-- Icons -->
<!-- 16x16 -->
<link rel="shortcut icon" href="http://doam.ru/favicon.ico">
<!-- 32x32 -->
<link rel="shortcut icon" href="http://doam.ru/favicon.png">
<!-- 57x57 (precomposed) for iPhone 3GS, pre-2011 iPod Touch and older Android devices -->
<link rel="apple-touch-icon-precomposed" href="http://doam.ru/images/apple-touch-icon-precomposed.png">
<!-- 72x72 (precomposed) for 1st generation iPad, iPad 2 and iPad mini -->
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="http://doam.ru/images/apple-touch-icon-72x72-precomposed.png">
<!-- 114x114 (precomposed) for iPhone 4, 4S, 5 and post-2011 iPod Touch -->
<link rel="apple-touch-icon-precomposed" sizes="114x114" href="http://doam.ru/images/apple-touch-icon-114x114-precomposed.png">
<!-- 144x144 (precomposed) for iPad 3rd and 4th generation -->
<link rel="apple-touch-icon-precomposed" sizes="144x144" href="http://doam.ru/images/apple-touch-icon-144x144-precomposed.png">
<!-- Google Tag Manager -->
<noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-MXNSQJ"
height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-MXNSQJ');</script>
<!-- End Google Tag Manager -->
<!-- Yandex.Metrika counter --><script type="text/javascript">(function (d, w, c) { (w[c] = w[c] || []).push(function() { try { w.yaCounter13571732 = new Ya.Metrika({id:13571732, webvisor:true, clickmap:true, trackLinks:true, accurateTrackBounce:true}); } catch(e) { } }); var n = d.getElementsByTagName("script")[0], s = d.createElement("script"), f = function () { n.parentNode.insertBefore(s, n); }; s.type = "text/javascript"; s.async = true; s.src = (d.location.protocol == "https:" ? "https:" : "http:") + "//mc.yandex.ru/metrika/watch.js"; if (w.opera == "[object Opera]") { d.addEventListener("DOMContentLoaded", f, false); } else { f(); } })(document, window, "yandex_metrika_callbacks");</script><noscript><div><img src="//mc.yandex.ru/watch/13571732" style="position:absolute; left:-9999px;" alt="" /></div></noscript><!-- /Yandex.Metrika counter -->

</head>

<body class="post">

<!--[if lt IE 9]><div class="browser-upgrade alert alert-info">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> to improve your experience.</div><![endif]-->

<div class="navigation-wrapper">
	<div class="site-name">
		<a href="http://doam.ru/">Diary of madman</a>
	</div><!-- /.site-name -->
	<div class="top-navigation">
		<nav role="navigation" id="site-nav" class="nav">
		    <ul>
		        
				    
				    <li><a href="http://doam.ru/tags/" >Теги</a></li>
				
				    
				    <li><a href="http://doam.ru/cv/" >Резюме</a></li>
				
		    </ul>
		</nav>
	</div><!-- /.top-navigation -->
</div><!-- /.navigation-wrapper -->



<div id="main" role="main">
  <div class="article-author-side sticky">
    

<div itemscope itemtype="http://schema.org/Person">


	<img src="http://doam.ru/images/bio-photo.jpg" class="bio-photo" alt="Антон Рябов bio photo">


  <h3 itemprop="name">Антон Рябов</h3>
  <p>Не люблю бриться и у меня умный взгляд.</p>
  <a href="mailto:mail@doam.ru" class="author-social" target="_blank"><i class="fa fa-fw fa-envelope-square"></i>Email</a>
  <a href="http://twitter.com/tonymadbrain" class="author-social" target="_blank"><i class="fa fa-fw fa-twitter-square"></i> Twitter</a>
  
  
  
  
  
  <a href="http://github.com/tonymadbrain" class="author-social" target="_blank"><i class="fa fa-fw fa-github"></i> Github</a>
  
  
  
  
  
  
  
  
  
  
  <a href="http://doam.ru/feed.xml" class="author-social" target="_blank"><i class="fa fa-fw fa-rss-square"></i> RSS</a>
</div>

  </div>
  <article class="post">
    <div class="headline-wrap">
      
        <h1><a href="http://doam.ru/understanding_enumerable_methods_by_re-implementing_them_in_ruby/" rel="bookmark" title="Понимание методов Enumerable методом реализации их на Ruby">Понимание методов Enumerable методом реализации их на Ruby</a></h1>
      
    </div><!--/ .headline-wrap -->
    <div class="article-wrap">
      <p><a href="http://ruby-doc.org/core-2.2.3/Enumerable.html" target="_blank">Enumerable</a> в Руби является, безусловно, одним из самых лучших примеров как нужно делать модули. Он предоставляет большой набор методов, полезных для обработки структур данных и требуют от вас реализовать только один метод - <code>each</code>. Так, для любого класса, который будет вести себя как коллекция и реализовывать метод <code>each</code>, может быть использован <em>Enumerable</em>.</p>

<section id="table-of-contents" class="toc">
  <header>
    <h3><i class="fa fa-book"></i> Обзор</h3>
  </header>
<div id="drawer">
<ul id="markdown-toc">
  <li><a href="#map" id="markdown-toc-map">map</a></li>
  <li><a href="#find" id="markdown-toc-find">find</a></li>
  <li><a href="#findall" id="markdown-toc-findall">find_all</a></li>
  <li><a href="#reduce" id="markdown-toc-reduce">reduce</a></li>
  <li><a href="#reduce-magic" id="markdown-toc-reduce-magic">reduce magic</a></li>
</ul>

  </div>
</section>
<!-- /#table-of-contents -->

<blockquote>
  <p>От переводчика: <a href="http://mauricio.github.io/2015/01/12/implementing-enumerable-in-ruby.html" target="_blank">Оригинал статьи</a></p>
</blockquote>

<p>Хороший способ понять как <em>Enumerable</em> работает - реализовать его основные методы. Реализовывая каждый метод самостоятельно, мы лучше понимаем, что каждый из них делает и как можно построить такую функциональность, которая требует реализации только одного метода.</p>

<p>Во-первых, нам нужен класс, который будет включать наш собственный модуль <code>CustomEnumerable</code>, давайте определим его:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">ArrayWrapper</span>

  <span class="kp">include</span> <span class="no">CustomEnumerable</span>

  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="o">*</span><span class="n">items</span><span class="p">)</span>
    <span class="vi">@items</span> <span class="o">=</span> <span class="n">items</span><span class="o">.</span><span class="n">flatten</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">each</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
    <span class="vi">@items</span><span class="o">.</span><span class="n">each</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
    <span class="nb">self</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">==</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
    <span class="vi">@items</span> <span class="o">==</span> <span class="n">other</span>
  <span class="k">end</span>

<span class="k">end</span></code></pre></figure>

<p>Здесь не так много кода, инклудим <code>CustomEnumerable</code> (нашу собственную реализацию <em>Enumerable</em>) и пишем враппер для Array. Также реализован метод <code>==</code>, который необязателен для функциональности <em>Enumerable</em>, но нужен нам чтобы легче использовать матчеры Rspec.</p>

<h3 id="map">map</h3>

<p>В документации про <code>map</code> написано:</p>

<blockquote>
  <p>Возвращает новый массив с результатами выполнения блока для каждого элемента в исходном массиве.</p>
</blockquote>

<p>Итак, наш код должен вызывать переданный блок кода на каждом элементе коллекции и затем генерировать новый массив с результатом выполнения каждого вызова. Давайте реализуем это:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">module</span> <span class="nn">CustomEnumerable</span>

  <span class="k">def</span> <span class="nf">map</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="o">[]</span>
    <span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">element</span><span class="o">|</span>
      <span class="n">result</span> <span class="o">&lt;&lt;</span> <span class="n">block</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
    <span class="k">end</span>
    <span class="n">result</span>
  <span class="k">end</span>

<span class="k">end</span></code></pre></figure>

<p>Это будет шаблон почти для всех методов, которые мы создаем: создаем целевой массив, вызываем метод <code>each</code> и делаем нужную работу. Важно знать, что наша реализация ничего не знает о том где будет включена (included), ожидается только, что у объекта будет метод <code>each</code>.</p>

<p>Чтобы увидеть <code>map</code> в действии давайте умножим каждый элемент массива на 2:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">it</span> <span class="s1">&#39;maps the numbers multiplying them by 2&#39;</span> <span class="k">do</span>
  <span class="n">items</span> <span class="o">=</span> <span class="no">ArrayWrapper</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
  <span class="n">result</span> <span class="o">=</span> <span class="n">items</span><span class="o">.</span><span class="n">map</span> <span class="k">do</span> <span class="o">|</span><span class="n">n</span><span class="o">|</span>
    <span class="n">n</span> <span class="o">*</span> <span class="mi">2</span>
  <span class="k">end</span>

  <span class="n">expect</span><span class="p">(</span><span class="n">result</span><span class="p">)</span><span class="o">.</span><span class="n">to</span> <span class="n">eq</span><span class="p">(</span><span class="o">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="o">]</span><span class="p">)</span>
<span class="k">end</span></code></pre></figure>

<h3 id="find">find</h3>

<p>Вот что говорит документация о <code>find</code>:</p>

<blockquote>
  <p>Помещает каждую запись массива в блок. Возвращает первое вхождение для которого блок не false. Если ни один объект не подошел вызывается переменная ifnone, если она не задана возвращается nil.</p>
</blockquote>

<p><code>find</code> используется чтобы искать объекты в <em>Enumerable</em> совпадающие с блоком, переданным в метод, давайте реализуем его:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="n">ifnone</span> <span class="o">=</span> <span class="kp">nil</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
  <span class="n">result</span> <span class="o">=</span> <span class="kp">nil</span>
  <span class="n">found</span> <span class="o">=</span> <span class="kp">false</span>
  <span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">element</span><span class="o">|</span>
    <span class="k">if</span> <span class="n">block</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
      <span class="n">result</span> <span class="o">=</span> <span class="n">element</span>
      <span class="n">found</span> <span class="o">=</span> <span class="kp">true</span>
      <span class="k">break</span>
    <span class="k">end</span>
  <span class="k">end</span>
  <span class="n">found</span> <span class="p">?</span> <span class="n">result</span> <span class="p">:</span> <span class="n">ifnone</span> <span class="o">&amp;&amp;</span> <span class="n">ifnone</span><span class="o">.</span><span class="n">call</span>
<span class="k">end</span></code></pre></figure>

<p>Вначале мы устанавливаем переменные, в одну мы сохраним результат, если он будет, а другая нужна в качестве сигнала, если мы действительно найдем значение. Почему бы просто не использовать переменную <code>result</code> со значением <code>nil</code> если мы ничего не нашли? Потому что <code>nil</code> может быть тем самым значением, которое ищет пользователь!</p>

<p>Итак, нам действительно нужно знать нашли мы что-то (неважно что это) или нет до того как будем возвращать результат. И если мы ничего не нашли то вызываем результат <code>ifnone</code>, если <code>ifnone</code> - <code>nil</code> просто вернем его.</p>

<p>Есть много вариантов использования для <code>find</code>, например мы можем искать элемент массива:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">it</span> <span class="s1">&#39;finds the item given a predicate&#39;</span> <span class="k">do</span>
  <span class="n">items</span> <span class="o">=</span> <span class="no">ArrayWrapper</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
  <span class="n">result</span> <span class="o">=</span> <span class="n">items</span><span class="o">.</span><span class="n">find</span> <span class="k">do</span> <span class="o">|</span><span class="n">element</span><span class="o">|</span>
    <span class="n">element</span> <span class="o">==</span> <span class="mi">3</span>
  <span class="k">end</span>

  <span class="n">expect</span><span class="p">(</span><span class="n">result</span><span class="p">)</span><span class="o">.</span><span class="n">to</span> <span class="n">eq</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="k">end</span></code></pre></figure>

<p>Мы можем изменить значение по-умолчанию если результат не найден:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">it</span> <span class="s1">&#39;returns the ifnone value if no item is found&#39;</span> <span class="k">do</span>
  <span class="n">items</span> <span class="o">=</span> <span class="no">ArrayWrapper</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
  <span class="n">result</span> <span class="o">=</span> <span class="n">items</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="nb">lambda</span> <span class="p">{</span><span class="mi">0</span><span class="p">})</span> <span class="k">do</span> <span class="o">|</span><span class="n">element</span><span class="o">|</span>
    <span class="n">element</span> <span class="o">&lt;</span> <span class="mi">1</span>
  <span class="k">end</span>
  <span class="n">expect</span><span class="p">(</span><span class="n">result</span><span class="p">)</span><span class="o">.</span><span class="n">to</span> <span class="n">eq</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="k">end</span></code></pre></figure>

<p>Это полезно если вы всегда хотите возвращать какое-то значение, даже если ничего не нашлось.</p>

<blockquote>
  <p>От переводчика: в случае выше, мы возвращаем ноль, если ничего не нашлось, вместо дефолтного nil.</p>
</blockquote>

<p>Ну и в простых случаях всегда можно оставить дефолтное значение:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">it</span> <span class="s2">&quot;returns nil if it can&#39;t find anything&quot;</span> <span class="k">do</span>
  <span class="n">items</span> <span class="o">=</span> <span class="no">ArrayWrapper</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
  <span class="n">result</span> <span class="o">=</span> <span class="n">items</span><span class="o">.</span><span class="n">find</span> <span class="k">do</span> <span class="o">|</span><span class="n">element</span><span class="o">|</span>
    <span class="n">element</span> <span class="o">==</span> <span class="mi">10</span>
  <span class="k">end</span>
  <span class="n">expect</span><span class="p">(</span><span class="n">result</span><span class="p">)</span><span class="o">.</span><span class="n">to</span> <span class="n">be_nil</span>
<span class="k">end</span></code></pre></figure>

<p>Все отлично, <code>find</code> возвращает первое совпадение в коллекции, но что если я хочу найти вернуть все значения внутри <em>Enumerable</em> удовлетворяющие критериям? Нам нужно использовать метод <code>find_all</code>!</p>

<h3 id="findall">find_all</h3>

<p>Снова обратимся к документации:</p>

<blockquote>
  <p>Возвращает массив, содержащий все элементы из перечисления для которых переданный блок возвращает значение <code>true</code></p>
</blockquote>

<p>Итак, теперь у нас нет значений по-умолчанию, метод всегда возвращает массив всех объектов для которых выполняется переданный в блоке код (или пустой массив в случае когда совпадений нет), давайте сделаем это:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">def</span> <span class="nf">find_all</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
  <span class="n">result</span> <span class="o">=</span> <span class="o">[]</span>
  <span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">element</span><span class="o">|</span>
    <span class="k">if</span> <span class="n">block</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
      <span class="n">result</span> <span class="o">&lt;&lt;</span> <span class="n">element</span>
    <span class="k">end</span>
  <span class="k">end</span>
  <span class="n">result</span>
<span class="k">end</span></code></pre></figure>

<p>Поскольку <code>find</code> выходит сразу же как только найдется результат, мы не можем использовать его в данном случае, наш метод <code>find_all</code> должен быть написан с нуля. Мы создаем массив, проходим по нашему перечислению, проверяя каждый элемент и если элемент подходит, добавляем его в массив с результатами, по окончанию мы возвращаем коллекцию с объектами, которые совпадают.</p>

<p>Давайте посмотрим на несколько примеров:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">it</span> <span class="s1">&#39;finds all the numbers that are greater than 2&#39;</span> <span class="k">do</span>
  <span class="n">items</span> <span class="o">=</span> <span class="no">ArrayWrapper</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
  <span class="n">result</span> <span class="o">=</span> <span class="n">items</span><span class="o">.</span><span class="n">find_all</span> <span class="k">do</span> <span class="o">|</span><span class="n">element</span><span class="o">|</span>
    <span class="n">element</span> <span class="o">&gt;</span> <span class="mi">2</span>
  <span class="k">end</span>
  <span class="n">expect</span><span class="p">(</span><span class="n">result</span><span class="p">)</span><span class="o">.</span><span class="n">to</span> <span class="n">eq</span><span class="p">(</span><span class="o">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="o">]</span><span class="p">)</span>
<span class="k">end</span>

<span class="n">it</span> <span class="s1">&#39;does not find anything&#39;</span> <span class="k">do</span>
  <span class="n">items</span> <span class="o">=</span> <span class="no">ArrayWrapper</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
  <span class="n">result</span> <span class="o">=</span> <span class="n">items</span><span class="o">.</span><span class="n">find_all</span> <span class="k">do</span> <span class="o">|</span><span class="n">element</span><span class="o">|</span>
    <span class="n">element</span> <span class="o">&gt;</span> <span class="mi">4</span>
  <span class="k">end</span>
  <span class="n">expect</span><span class="p">(</span><span class="n">result</span><span class="p">)</span><span class="o">.</span><span class="n">to</span> <span class="n">be_empty</span>
<span class="k">end</span></code></pre></figure>

<p>Даже если совпадений не будет, код вернет массив (хоть и пустой), так что при использовании <code>find_all</code> нужно не забывать проверять что массив имеет объекты или нет (вместо проверки на nil, как это было сделано в <code>find</code>).</p>

<h3 id="reduce">reduce</h3>

<p><code>reduce</code> или <code>inject</code> (также известный как <code>foldLeft</code> в других языках как OCaml или Scala) это метод который обрабатывает элементы <em>enum</em> применяя к ним блок, принимающий два параметра - аккумулятор (memo) и обрабатываемый элемент. На каждом шаге аккумулятору <em>memo</em> присваивается значение, возвращенное блоком. Первая форма позволяет присвоить аккумулятору некоторое исходное значение. Вторая форма в качестве исходного значения аккумулятора использует первый элемент коллекции (пропуская этот элемент при проходе). Хоть и звучит странно, это очень полезная функция.</p>

<p>Давайте посмотрим в документацию:</p>

<blockquote>
  <p>Комбинирует все элементы в <em>enum</em>, применяя бинарную операцию, переданную в виде блока или символа в метод.</p>
</blockquote>

<blockquote>
  <p>If you specify a block, then for each element in enum the block is passed an accumulator value (memo) and the element. If you specify a symbol instead, then each element in the collection will be passed to the named method of memo. In either case, the result becomes the new value for memo. At the end of the iteration, the final value of memo is the return value for the method.</p>
</blockquote>

<blockquote>
  <p>Если явно не указано начальное значение для <em>memo</em>, то первый элемент коллекции используется в качестве начального значения <em>memo</em>.</p>
</blockquote>

<p>Таким образом, мы должны получить блок или символ и мы можем получить начальное значение, если оно не передано, то в качестве начального значения будет использоваться первый элемент. Эта реализация на самом будет немного сложнее, давайте начнем с простого случая когда мы передаем в метод и блок и начальное значение:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">def</span> <span class="nf">reduce</span><span class="p">(</span><span class="n">accumulator</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
  <span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">element</span><span class="o">|</span>
    <span class="n">accumulator</span> <span class="o">=</span> <span class="n">block</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">accumulator</span><span class="p">,</span> <span class="n">element</span><span class="p">)</span>
  <span class="k">end</span>
  <span class="n">accumulator</span>
<span class="k">end</span></code></pre></figure>

<p>Итак, это довольно просто, мы вызываем блок с аккумлятором и элементом и следующий аккумулятор это производная вызова блока. Довольно простая реализация, но эта абстракция невероятно мощная и доступна во всех функциональных языках программирования для аггрегации (reduce в данном случае, это часть парадигмы map-reduce).</p>

<p>Давайте посмотрим на пример:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">it</span> <span class="s1">&#39;sums all numbers&#39;</span> <span class="k">do</span>
  <span class="n">items</span> <span class="o">=</span> <span class="no">ArrayWrapper</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
  <span class="n">result</span> <span class="o">=</span> <span class="n">items</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">accumulator</span><span class="p">,</span><span class="n">element</span><span class="o">|</span>
    <span class="n">accumulator</span> <span class="o">+</span> <span class="n">element</span>
  <span class="k">end</span>
  <span class="n">expect</span><span class="p">(</span><span class="n">result</span><span class="p">)</span><span class="o">.</span><span class="n">to</span> <span class="n">eq</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="k">end</span></code></pre></figure>

<p>И в примере у нас простая reduce функция, которая производит сложение всех элементов. Также важно проверить случай, когда <em>enum</em> пустой, если это так, функция должна вернуть начальное значение:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">it</span> <span class="s1">&#39;returns the accumulator if no value was provided&#39;</span> <span class="k">do</span>
  <span class="n">items</span> <span class="o">=</span> <span class="no">ArrayWrapper</span><span class="o">.</span><span class="n">new</span>
  <span class="n">result</span> <span class="o">=</span> <span class="n">items</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="mi">50</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">accumulator</span><span class="p">,</span><span class="n">element</span><span class="o">|</span>
   <span class="n">accumulator</span> <span class="o">+</span> <span class="n">element</span>
  <span class="k">end</span>
  <span class="n">expect</span><span class="p">(</span><span class="n">result</span><span class="p">)</span><span class="o">.</span><span class="n">to</span> <span class="n">eq</span><span class="p">(</span><span class="mi">50</span><span class="p">)</span>
<span class="k">end</span></code></pre></figure>

<p>Теперь, давайте добавим первый опциональный параметр, символ операции который применяется вместо блока.</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">def</span> <span class="nf">reduce</span><span class="p">(</span><span class="n">accumulator</span><span class="p">,</span> <span class="n">operation</span> <span class="o">=</span> <span class="kp">nil</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">operation</span> <span class="o">&amp;&amp;</span> <span class="n">block</span>
    <span class="k">raise</span> <span class="no">ArgumentError</span><span class="p">,</span> <span class="s2">&quot;you must provide either an operation symbol or a block, not both&quot;</span>
  <span class="k">end</span>

  <span class="n">block</span> <span class="o">=</span> <span class="k">case</span> <span class="n">operation</span>
    <span class="k">when</span> <span class="no">Symbol</span>
      <span class="nb">lambda</span> <span class="p">{</span> <span class="o">|</span><span class="n">acc</span><span class="p">,</span><span class="n">value</span><span class="o">|</span> <span class="n">acc</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">operation</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="p">}</span>
    <span class="k">when</span> <span class="kp">nil</span>
      <span class="n">block</span>
    <span class="k">else</span>
      <span class="k">raise</span> <span class="no">ArgumentError</span><span class="p">,</span> <span class="s2">&quot;the operation provided must be a symbol&quot;</span>
  <span class="k">end</span>

  <span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">element</span><span class="o">|</span>
    <span class="n">accumulator</span> <span class="o">=</span> <span class="n">block</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">accumulator</span><span class="p">,</span> <span class="n">element</span><span class="p">)</span>
  <span class="k">end</span>
  <span class="n">accumulator</span>
<span class="k">end</span></code></pre></figure>

<p>Фактически реализация особо не поменялась, мы добавили проверку которая исключает случаи передачи в метод лишнего, так как должен быть передан либо символ операции либо блок. Далее мы определяем блок, если в <code>operation</code> передан символ то используем его, если там <code>nil</code> то присваим блок в <code>block</code> иначе вызываем ошибку. Основная петля (loop - т.е. проход по элементам перечисления) по факту не изменилась.</p>

<p>Теперь посмотрим на использование:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">it</span> <span class="s1">&#39;executes the operation provided&#39;</span> <span class="k">do</span>
  <span class="n">items</span> <span class="o">=</span> <span class="no">ArrayWrapper</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
  <span class="n">result</span> <span class="o">=</span> <span class="n">items</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="ss">:+</span><span class="p">)</span>
  <span class="n">expect</span><span class="p">(</span><span class="n">result</span><span class="p">)</span><span class="o">.</span><span class="n">to</span> <span class="n">eq</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="k">end</span></code></pre></figure>

<p>Первое - базовое использование, вызов <code>reduce</code> с символом, который применяется к аккумулятору и каждому значению. Это тот же самый пример что и для нашей первой реализации <code>reduce</code>, но теперь используется меньше кода.</p>

<p>Теперь давайте посмотри на ошибочные варианты, во-первых передадим в метод и оператор и блок:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">it</span> <span class="s2">&quot;fails if both a symbol and a block are provided&quot;</span> <span class="k">do</span>
  <span class="n">items</span> <span class="o">=</span> <span class="no">ArrayWrapper</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
  <span class="n">expect</span> <span class="k">do</span>
    <span class="n">items</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="ss">:+</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">accumulator</span><span class="p">,</span><span class="n">element</span><span class="o">|</span>
      <span class="n">accumulator</span> <span class="o">+</span> <span class="n">element</span>
    <span class="k">end</span>
  <span class="k">end</span><span class="o">.</span><span class="n">to</span> <span class="n">raise_error</span><span class="p">(</span><span class="no">ArgumentError</span><span class="p">,</span> <span class="s2">&quot;you must provide either an operation symbol or a block, not both&quot;</span><span class="p">)</span>
<span class="k">end</span></code></pre></figure>

<p>Когда переданы оба параметра, мы должны выдать ошибку, потому что непонятно что хочет пользователь. Тоже если то, что передано в <code>operation</code> не является символом.</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">it</span> <span class="s1">&#39;fails if the operation provided is not a symbol&#39;</span> <span class="k">do</span>
  <span class="n">items</span> <span class="o">=</span> <span class="no">ArrayWrapper</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
  <span class="n">expect</span> <span class="k">do</span>
    <span class="n">items</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;+&#39;</span><span class="p">)</span>
  <span class="k">end</span><span class="o">.</span><span class="n">to</span> <span class="n">raise_error</span><span class="p">(</span><span class="no">ArgumentError</span><span class="p">,</span> <span class="s2">&quot;the operation provided must be a symbol&quot;</span><span class="p">)</span>
<span class="k">end</span></code></pre></figure>

<p>Не <code>Symbol</code>? Извини, не могу это использовать.
&lt;/br&gt;
Теперь, последний шаг нашей реализации - параметр аккумулятор теперь опциональный. Если его нет, должен быть использован первый элемент коллекции. Теперь у нас есть 4 варианта использования <code>reduce</code>:</p>

<ul>
  <li><code>accumulator</code> + блок кода</li>
  <li><code>accumulator</code> + <code>operation</code></li>
  <li><code>operation</code></li>
  <li>без параметро + блок</li>
</ul>

<p>Давайте сделаем тесты для двух случаев, которые мы пропустили ранее, вызов только <code>operation</code>:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">it</span> <span class="s1">&#39;executes the operation provided without an initial value&#39;</span> <span class="k">do</span>
  <span class="n">items</span> <span class="o">=</span> <span class="no">ArrayWrapper</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
  <span class="n">result</span> <span class="o">=</span> <span class="n">items</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="ss">:+</span><span class="p">)</span>
  <span class="n">expect</span><span class="p">(</span><span class="n">result</span><span class="p">)</span><span class="o">.</span><span class="n">to</span> <span class="n">eq</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="k">end</span></code></pre></figure>

<p>И вызов только блока:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">it</span> <span class="s1">&#39;executes the block provided without an initial value&#39;</span> <span class="k">do</span>
  <span class="n">items</span> <span class="o">=</span> <span class="no">ArrayWrapper</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
  <span class="n">result</span> <span class="o">=</span> <span class="n">items</span><span class="o">.</span><span class="n">reduce</span> <span class="k">do</span> <span class="o">|</span><span class="n">accumulator</span><span class="p">,</span><span class="n">element</span><span class="o">|</span>
    <span class="n">accumulator</span> <span class="o">+</span> <span class="n">element</span>
  <span class="k">end</span>
  <span class="n">expect</span><span class="p">(</span><span class="n">result</span><span class="p">)</span><span class="o">.</span><span class="n">to</span> <span class="n">eq</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="k">end</span></code></pre></figure>

<p>Почему эти два теста?</p>

<p>Посмотрим на них, в общем-то они одинаковые, в обоих случаях нет аккумулятора, разница только в том, что в одном передается блок, но оба должны вытащить первый элемент коллекции и затем запустить <code>reduce</code>.</p>

<p>Если мы попробуем запустить эти тесты:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="ss">Failures</span><span class="p">:</span>

<span class="mi">1</span><span class="p">)</span> <span class="no">CustomEnumerable</span> <span class="n">reduce</span> <span class="n">executes</span> <span class="n">the</span> <span class="n">operation</span> <span class="n">provided</span> <span class="n">without</span> <span class="n">an</span> <span class="n">initial</span> <span class="n">value</span>
  <span class="no">Failure</span><span class="o">/</span><span class="ss">Error</span><span class="p">:</span> <span class="vi">@items</span><span class="o">.</span><span class="n">each</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
  <span class="ss">NoMethodError</span><span class="p">:</span>
  <span class="n">undefined</span> <span class="nb">method</span> <span class="sb">`call&#39; for nil:NilClass</span>
<span class="sb">  # ./lib/custom_enumerable.rb:47:in `</span><span class="n">block</span> <span class="k">in</span> <span class="n">reduce</span><span class="s1">&#39;</span>
<span class="s1">  # ./spec/custom_enumerable_spec.rb:12:in `each&#39;</span>
  <span class="c1"># ./spec/custom_enumerable_spec.rb:12:in `each&#39;</span>
  <span class="c1"># ./lib/custom_enumerable.rb:46:in `reduce&#39;</span>
  <span class="c1"># ./spec/custom_enumerable_spec.rb:128:in `block (3 levels) in &lt;top (required)&gt;&#39;</span>

<span class="mi">2</span><span class="p">)</span> <span class="no">CustomEnumerable</span> <span class="n">reduce</span> <span class="n">executes</span> <span class="n">the</span> <span class="n">block</span> <span class="n">provided</span> <span class="n">without</span> <span class="n">an</span> <span class="n">initial</span> <span class="n">value</span>
  <span class="no">Failure</span><span class="o">/</span><span class="ss">Error</span><span class="p">:</span> <span class="n">result</span> <span class="o">=</span> <span class="n">items</span><span class="o">.</span><span class="n">reduce</span> <span class="k">do</span> <span class="o">|</span><span class="n">accumulator</span><span class="p">,</span><span class="n">element</span><span class="o">|</span>
  <span class="ss">ArgumentError</span><span class="p">:</span>
  <span class="n">wrong</span> <span class="n">number</span> <span class="n">of</span> <span class="n">arguments</span> <span class="p">(</span><span class="mi">0</span> <span class="k">for</span> <span class="mi">1</span><span class="o">.</span><span class="n">.</span><span class="mi">2</span><span class="p">)</span>
  <span class="c1"># ./lib/custom_enumerable.rb:32:in `reduce&#39;</span>
  <span class="c1"># ./spec/custom_enumerable_spec.rb:134:in `block (3 levels) in &lt;top (required)&gt;&#39;</span></code></pre></figure>

<p>Как мы будем делать это? Большая часть кода будет заниматься жонглированием параметров. <code>reduce</code> был объявлен задолго до того как в <code>ruby</code> появились именованные параметры, нет магического способа определить аккумулятор это операция или нет, мы должны проверить это вручную.</p>

<p>Также, нам нужен способ получить первый элемент коллекции, иначе нам придется это делать в самом методе <code>reduce</code>. Давайте начнем с реализации метода <code>first</code>:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">def</span> <span class="nf">first</span>
  <span class="n">found</span> <span class="o">=</span> <span class="kp">nil</span>
  <span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">element</span><span class="o">|</span>
    <span class="n">found</span> <span class="o">=</span> <span class="n">element</span>
    <span class="k">break</span>
  <span class="k">end</span>
  <span class="n">found</span>
<span class="k">end</span></code></pre></figure>

<p>Использовать его очень просто:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">it</span> <span class="s1">&#39;returns the first element inside a collection&#39;</span> <span class="k">do</span>
  <span class="n">items</span> <span class="o">=</span> <span class="no">ArrayWrapper</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
  <span class="n">expect</span><span class="p">(</span><span class="n">items</span><span class="o">.</span><span class="n">first</span><span class="p">)</span><span class="o">.</span><span class="n">to</span> <span class="n">eq</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="k">end</span>

<span class="n">it</span> <span class="s1">&#39;returns nil if the collection is empty&#39;</span> <span class="k">do</span>
  <span class="n">items</span> <span class="o">=</span> <span class="no">ArrayWrapper</span><span class="o">.</span><span class="n">new</span>
  <span class="n">expect</span><span class="p">(</span><span class="n">items</span><span class="o">.</span><span class="n">first</span><span class="p">)</span><span class="o">.</span><span class="n">to</span> <span class="n">be_nil</span>
<span class="k">end</span></code></pre></figure>

<p>Если вы спрашиваете себя - почему он использует <code>break</code> а не просто возвращает элемент из <code>each</code>, попробуйте поменять код на:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">def</span> <span class="nf">first</span>
  <span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">element</span><span class="o">|</span>
    <span class="k">return</span> <span class="n">element</span>
  <span class="k">end</span>
<span class="k">end</span></code></pre></figure>

<p><br />
Что сейчас произошло?
<br />
Вторая спека которая ожидает что вернется <code>nil</code>, когда коллекция пустая, провалилась. Почему? Потому что <code>each</code> возвращает саму коллекцию когда запускается, так как код ни разу не был выполнен (коллекция пустая!) <code>each</code> просто возвращает себя а не <code>nil</code>, как мы ожидаем. Вот почему нам нужно использовать <code>return</code> и <code>break</code>.</p>

<p>Теперь, когда метод <code>first</code> написан, давайте сделаем финальную реализацию <code>reduce</code>:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">def</span> <span class="nf">reduce</span><span class="p">(</span><span class="n">accumulator</span> <span class="o">=</span> <span class="kp">nil</span><span class="p">,</span> <span class="n">operation</span> <span class="o">=</span> <span class="kp">nil</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">accumulator</span><span class="o">.</span><span class="n">nil?</span> <span class="o">&amp;&amp;</span> <span class="n">operation</span><span class="o">.</span><span class="n">nil?</span> <span class="o">&amp;&amp;</span> <span class="n">block</span><span class="o">.</span><span class="n">nil?</span>
    <span class="k">raise</span> <span class="no">ArgumentError</span><span class="p">,</span> <span class="s2">&quot;you must provide an operation or a block&quot;</span>
  <span class="k">end</span>

  <span class="k">if</span> <span class="n">operation</span> <span class="o">&amp;&amp;</span> <span class="n">block</span>
    <span class="k">raise</span> <span class="no">ArgumentError</span><span class="p">,</span> <span class="s2">&quot;you must provide either an operation symbol or a block, not both&quot;</span>
  <span class="k">end</span>

  <span class="k">if</span> <span class="n">operation</span><span class="o">.</span><span class="n">nil?</span> <span class="o">&amp;&amp;</span> <span class="n">block</span><span class="o">.</span><span class="n">nil?</span>
    <span class="n">operation</span> <span class="o">=</span> <span class="n">accumulator</span>
    <span class="n">accumulator</span> <span class="o">=</span> <span class="kp">nil</span>
  <span class="k">end</span>

  <span class="n">block</span> <span class="o">=</span> <span class="k">case</span> <span class="n">operation</span>
    <span class="k">when</span> <span class="no">Symbol</span>
      <span class="nb">lambda</span> <span class="p">{</span> <span class="o">|</span><span class="n">acc</span><span class="p">,</span> <span class="n">value</span><span class="o">|</span> <span class="n">acc</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">operation</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="p">}</span>
    <span class="k">when</span> <span class="kp">nil</span>
      <span class="n">block</span>
    <span class="k">else</span>
    <span class="k">raise</span> <span class="no">ArgumentError</span><span class="p">,</span> <span class="s2">&quot;the operation provided must be a symbol&quot;</span>
  <span class="k">end</span>

  <span class="k">if</span> <span class="n">accumulator</span><span class="o">.</span><span class="n">nil?</span>
    <span class="n">ignore_first</span> <span class="o">=</span> <span class="kp">true</span>
    <span class="n">accumulator</span> <span class="o">=</span> <span class="n">first</span>
  <span class="k">end</span>

  <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span>

  <span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">element</span><span class="o">|</span>
    <span class="k">unless</span> <span class="n">ignore_first</span> <span class="o">&amp;&amp;</span> <span class="n">index</span> <span class="o">==</span> <span class="mi">0</span>
      <span class="n">accumulator</span> <span class="o">=</span> <span class="n">block</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">accumulator</span><span class="p">,</span> <span class="n">element</span><span class="p">)</span>
    <span class="k">end</span>
    <span class="n">index</span> <span class="o">+=</span> <span class="mi">1</span>
  <span class="k">end</span>
  <span class="n">accumulator</span>
<span class="k">end</span></code></pre></figure>

<p>Учитывая, что мы не знаем как будут переданы параметры или структуру коллекции, мы не можем оптимизировать данный вызов (если только не задублируем код немного, например, добавив упорядочивание реализации если переда аккумулятор). Но, так как мы хотим, чтобы код работал во всех случаях, мы будем надеяться что классы, включающие данный модуль будут предоставлять реализацию с более ровными структурами.</p>

<p>Код начинается с проверки всех параметров, если параметры не переданы, выходим, нечего делать. Далее начинается проверка какую ситуацию мы решаем, вначале проверяется - если <code>operation</code> и <code>block</code> - <code>nil</code>, значит поле <code>accumulator</code> должно быть операцией и значит у нас нет аккумулятора.</p>

<p>Когда у нас есть параметр <code>operation</code> мы достигаем другого куска, проверка аккумулятора. Если аккумулятор <code>nil</code>, мы должны брать первый элемент коллекции, а также сказать методу игнорировать первую итерацию.</p>

<p>Наша новая петля <code>each</code> теперь проверяет специальные переменные в случае пустого аккумулятора, так что мы можем безопасно обрабатывать коллекцию без дублирования значений. Это, кстати, неплохое место для оптимизации.</p>

<p>И это завершает реализацию метода <code>reduce</code>, посмотрите можете ли вы найти более быстрое или качественное решение, безусловно есть варианты лучше моего.</p>

<h3 id="reduce-magic">reduce magic</h3>

<p>Теперь, когда у нас есть реализация <code>reduce</code>, есть много методов, которые мы можем построить на его базе, например <code>min</code> и <code>max</code>:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">def</span> <span class="nf">min</span>
  <span class="n">reduce</span> <span class="k">do</span> <span class="o">|</span><span class="n">accumulator</span><span class="p">,</span><span class="n">element</span><span class="o">|</span>
    <span class="n">accumulator</span> <span class="o">&gt;</span> <span class="n">element</span> <span class="p">?</span> <span class="n">element</span> <span class="p">:</span> <span class="n">accumulator</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">max</span>
  <span class="n">reduce</span> <span class="k">do</span> <span class="o">|</span><span class="n">accumulator</span><span class="p">,</span><span class="n">element</span><span class="o">|</span>
    <span class="n">accumulator</span> <span class="o">&lt;</span> <span class="n">element</span> <span class="p">?</span> <span class="n">element</span> <span class="p">:</span> <span class="n">accumulator</span>
  <span class="k">end</span>
<span class="k">end</span></code></pre></figure>

<p>Наш <code>reduce</code> уже обрабатывает вариант с пустым значением:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">it</span> <span class="s1">&#39;produces nil if it is empty&#39;</span> <span class="k">do</span>
  <span class="n">items</span> <span class="o">=</span> <span class="no">ArrayWrapper</span><span class="o">.</span><span class="n">new</span>
  <span class="n">expect</span><span class="p">(</span><span class="n">items</span><span class="o">.</span><span class="n">max</span><span class="p">)</span><span class="o">.</span><span class="n">to</span> <span class="n">be_nil</span>
<span class="k">end</span></code></pre></figure>

<p>И случай одиночного варианта:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">it</span> <span class="s1">&#39;produces 1 as the max result&#39;</span> <span class="k">do</span>
  <span class="n">items</span> <span class="o">=</span> <span class="no">ArrayWrapper</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
  <span class="n">expect</span><span class="p">(</span><span class="n">items</span><span class="o">.</span><span class="n">max</span><span class="p">)</span><span class="o">.</span><span class="n">to</span> <span class="n">eq</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="k">end</span></code></pre></figure>

<p>Нашим реализациям <code>min</code> и <code>max</code> не нужно заботиться об этом, все что нужно сделать это передать блок который делает сравнение и возвращает наибольший или наименьший элемент, всю остальную работу делает <code>reduce</code>. Мощно, не так ли?</p>

<p>Есть еще много методов <code>Enumerable</code> помимо <code>reduce</code>, такие как <code>each_with_index</code>, <code>each_with_object</code>, <code>count</code>, <code>max_by, min_by</code> и другие, попробуйте также реализовать их на <code>ruby</code>.</p>

<p>Ну и все что было сделано в этом примере доступно на <a href="https://github.com/mauricio/enumerable_example" target="_blank">github</a>.</p>


      
        <a href="/tag/ruby">#Ruby</a>
      
        <a href="/tag/enumerable">#Enumerable</a>
      
        <a href="/tag/tutorial">#Tutorial</a>
      
        <!-- <a href="/tag/ruby/" rel="tag">Ruby</a>, <a href="/tag/enumerable/" rel="tag">Enumerable</a>, <a href="/tag/tutorial/" rel="tag">Tutorial</a> -->
      <hr />
      <footer role="contentinfo">
        <p class="byline"><strong>Понимание методов Enumerable методом реализации их на Ruby</strong> опубликовано <time datetime="2015-10-21T17:26:45+03:00">21 October, 2015</time>.</p>
        <div style="text-align: center;" class="social-share">
  <h4>Поделиться</h4>
  <ul>
    <li>
      <a href="https://twitter.com/intent/tweet?text=Понимание методов Enumerable методом реализации их на Ruby %23doamru http://doam.ru/understanding_enumerable_methods_by_re-implementing_them_in_ruby/" target="_blank" class="twitter" title="Share on Twitter"><i class="fa fa-twitter"></i><span> Twitter</span></a>
    </li>
    <li>
      <a href="http://vk.com/share.php?url=http://doam.ru/understanding_enumerable_methods_by_re-implementing_them_in_ruby/" class="vk" title="Share on VK" target="_blank"><i class="fa fa-vk"></i><span>ВКонтакте</span></a>
    </li>
    <li>
      <a href="https://www.facebook.com/sharer/sharer.php?u=http://doam.ru/understanding_enumerable_methods_by_re-implementing_them_in_ruby/" target="_blank" class="facebook" title="Share on Facebook"><i class="fa fa-facebook"></i><span> Facebook</span></a>
    </li>
    <li>
      <a href="https://plus.google.com/share?url=http://doam.ru/understanding_enumerable_methods_by_re-implementing_them_in_ruby/" target="_blank"class="google-plus" title="Share on Google Plus"><i class="fa fa-google-plus"></i><span> Google+</span></a>
    </li>
  </ul>
  <div class="mailerlite-subscribe-form">
    <script type="text/javascript" src="//app.mailerlite.com/data/webforms/225081/h4i6o3.js?v1"></script>
  </div>
</div><!-- /.social-share -->


      </footer>
    </div><!-- /.article-wrap -->
  
  </article>
</div><!-- /#main -->

<div class="footer-wrap">
  <div class="related-articles">
  <h4>Вас могут заинтересовать <small class="pull-right">(<a href="http://doam.ru">Смотреть все записи</a>)</small></h4>
    <ul>
    
      <li><a href="http://doam.ru/teeeeeeeeeeeest/" title="Teeeeeeeeeeeest">Teeeeeeeeeeeest</a></li>
    
      <li><a href="http://doam.ru/closing_the_2016_cycling_season/" title="Закрытие велосезона 2016">Закрытие велосезона 2016</a></li>
    
      <li><a href="http://doam.ru/deploying_ssl_private_keys_with_ansible/" title="Деплой приватных SSL ключей с помощью Ansible">Деплой приватных SSL ключей с помощью Ansible</a></li>
    
    </ul>
    <hr />
  </div><!-- /.related-articles -->
  <footer>
    <a href="#" class="go-top">Наверх</a>


<div style="text-align: center;"><span>&copy; 2011 - 2016 Diary of madman.</span></div><br>
<div style="text-align: center;"><span><a href="http://doam.ru/license/" target="_blank"><img src="http://doam.ru/license.png"></a></span></div>

  </footer>
</div><!-- /.footer-wrap -->

<script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="http://doam.ru/assets/js/vendor/jquery-1.9.1.min.js"><\/script>')</script>
<script src="http://doam.ru/assets/js/scripts.min.js"></script>



</body>
</html>
